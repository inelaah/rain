## 함수의 구분
ES6에서는 함수를 사용 목적에 따라 세 가지 종류로 명확히 구분하였다. 일반함수는 `constructor` 이지만 메서드와 화살표 함수는 `non-constructor` 이다.

### 메서드
ES6 사양에서 메서드는 메서드 축약 표현으로 정의된 함수만을 의미한다. **메서드는 super 키워드를 사용할 수 있다.**
```js
const obj = {
  x:1,
  // foo는 메서드이다.
  foo() { return this.x; }
```

### 화살표 함수
함수의 몸체가 하나의 문으로 구성된다면 함수 몸체를 감싸는 중괄호를 생략할 수 있다. 이때 함수 몸체 내부의 문이 값으로 평가될 수 있는 표현식인 문이라면 암묵적으로 반환된다. 함수 몸체가 하나의 문으로 구성된다 해도 함수 몸체의 문이 표현식이 아닌 문이라면 중괄호를 생략할 수 없다.

객체 리터럴을 반환하는 경우 객체 리터럴을 소괄호 ()로 감싸 주어야 한다.
```js
const create = (id, content) => ({id, content});
create(1, 'JavaScript'); // {id: 1, content: "JavaScript"}
```

**화살표 함수는 인스턴스를 생성할 수 없다.**

**화살표 함수는 중복된 매개변수 이름을 선언할 수 없다.**

**화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다.**
따라서 화살표 함수 내부에서 위를 참조하면 상위 스코프의 this, super 등을 참조한다.

### this
`this` 에 대해서는 앞에서도 설명한 바 있지만 여기서 주의할 것은 일반 함수로서 호출되는 콜백 함수의 경우이다. 
```js
class Prefixer {
  constructor(prefix) {
    this.prefix = prefix;
  }
  
  add(arr) {
    return arr.map(function (item) {
      return this.prefix + item; // TypeError
    });
  }
}

const prefixer = new Prefixer('-webkit-');
console.log(prefixer.add(['transition', 'user-select']));
```
위 예제에서는 Array.prototype.map 메서드가 콜백함수를 일반 함수로서 호출하기 때문에 `undefined`를 가리킨다. 클래스 내부의 모든 코드에는 strict mode가 암묵적으로 적용된다. 따라서 Array.prototype.map 메서드의 콜백 함수에도 이것이 적용된다. 즉 외부 함수의 this와 콜백 함수 this가 가리키는 값이 다르기 때문에 TypeError가 발생한 것이다.

ES6에서는 화살표 함수를 사용하여 콜백 함수 내부의 this 문제를 해결할 수 있다. 

```js
class Prefixer {
  constructor(prefix) {
    this.prefix = prefix;
  }
  
  add(arr) {
    return arr.map(item => this.prefix + item);
  }
}

const prefixer = new Prefixer('-webkit-');
console.log(prefixer.add(['transition', 'user-select']));
```
어떠한 원리일까?
__화살표 함수는 함수 자체의 this 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다. 이를 `lexical this`라 한다.__ 화살표 함수는 함수 자체의 this 바인딩이 존재하지 않기 때문에 상위 스코프에서 this를 탐색하게 된다.

### Rest 파라미터
Rest 파라미터는 매개변수 이름 앞에 세개의 점 `...` 을 붙여서 정의한 매개변수를 의미한다. __Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다.__

Rest 파라미터는 이름 그대로 먼저 선언된 매개변수에 할당된 인수를 제외한 나머지 인수들로 구성된 배열이 할당된다. 따라서 Rest 파라미터는 반드시 마지막 파라미터이어야 한다. 또한 Rest 파라미터는 단 하나만 선언할 수 있다.

ES6에서는 rest 파라미터를 사용하여 가변 인자 함수의 인수 목록을 배열로 직접 전달받을 수 있다. 이를 통해 유사 배열 객체인 arguments 객체를 배열로 변환하는 번거로움을 피할 수 있다.
```js
function sum(...args) {
  return args.reduce((pre, cur) => pre + cur, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // 15
```

### 매개변수 기본값
ES6에서 도입된 매개변수 기본값을 사용하면 함수 내에서 수행하던 인수 체크 및 초기화를 간소화할 수 있다.
__단 매개변수 기본값은 매개변수에 인수를 전달하지 않은 경우와 undefined를 전달한 경우에만 유효하다.__

```js
function sum(x = 0, y = 0) {
  return x + y;
}

console.log(sum(1,2)); // 3
console.log(sum(1)); // 1
```

```js
function logName(name = 'Lee') {
  console.log(name);
}

logName(); // Lee
logName(undefined); // Lee
logName(null); // null
```
